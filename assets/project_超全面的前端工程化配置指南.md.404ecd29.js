import{o as e,c as o,e as t}from"./app.c30441d1.js";const n='{"title":"前端工程化配置指南","description":"","frontmatter":{},"headers":[{"level":2,"title":"前端工程化配置指南","slug":"前端工程化配置指南"},{"level":2,"title":"示例","slug":"示例"},{"level":2,"title":"初始化","slug":"初始化"},{"level":2,"title":"配置","slug":"配置"},{"level":3,"title":"Typescript","slug":"typescript"},{"level":3,"title":"Eslint & Prettier","slug":"eslint-prettier"},{"level":3,"title":"Husky","slug":"husky"},{"level":3,"title":"Commitlint","slug":"commitlint"},{"level":3,"title":"Jest","slug":"jest"},{"level":3,"title":"Github Actions","slug":"github-actions"},{"level":2,"title":"结语","slug":"结语"}],"relativePath":"project/超全面的前端工程化配置指南.md","lastUpdated":1661330957047}',c={},d=[t('<p><img src="https://qn.huat.xyz/mac/20220716185129.png" alt=""></p><p><strong>程序员成长指北</strong></p><p>专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师。一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。</p><p>94篇原创内容</p><p>公众号</p><p>大厂技术  高级前端  Node进阶</p><p>点击上方 程序员成长指北，关注公众号</p><p>回复1，加入高级Node交流群</p><blockquote><p>作者：molvqingtai</p><p>原文链接: <a href="https://juejin.cn/post/6971812117993226248" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6971812117993226248</a></p></blockquote><h2 id="前端工程化配置指南">前端工程化配置指南</h2><blockquote><p>本文讲解如何构建一个工程化的前端库，并结合 Github Actions，自动发布到 Github 和 NPM 的整个详细流程。</p></blockquote><h2 id="示例">示例</h2><blockquote><p>我们经常看到像 Vue、React 这些流行的开源项目有很多配置文件，他们是干什么用的？他们的 Commit、Release 记录都那么规范，是否基于某种约定？</p></blockquote><p><strong>废话少说，先上图！</strong></p><p><img src="https://qn.huat.xyz/mac/20220716185137.png" alt="图片"> 上图标红就是相关的工程化配置，有 Linter、Tests，Github Actions 等，覆盖开发、测试、发布的整个流程。</p><p><strong>相关配置清单</strong></p><ul><li><p>Eslint</p></li><li><p>Prettier</p></li><li><p>Commitlint</p></li><li><p>Husky</p></li><li><p>Jest</p></li><li><p>GitHub Actions</p></li><li><p>Semantic Release</p></li></ul><p>下面我们从创建一个 TypeScript 项目开始，一步一步完成所有的工程化配置，并说明每个配置含义以及容易踩的坑。</p><h2 id="初始化">初始化</h2><p>为了避免兼容性问题，建议先将 node 升级到最新的长期支持版本。</p><p>首先在 Github 上创建一个 repo,拉下来之后通过<code>npm init -y</code>初始化。然后创建<code>src</code>文件夹，写入<code>index.ts</code>。</p><p><code>package.json</code> 生成之后，我需要添加如下配置项:</p><div class="language-auto"><pre><code>   &quot;main&quot;: &quot;index.js&quot;,\n+  &quot;type&quot;: &quot;module&quot;,\n   &quot;scripts&quot;: {\n     &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n   },\n+  &quot;publishConfig&quot;: {\n+    &quot;access&quot;: &quot;public&quot;\n+  }\n</code></pre></div><p>我们将项目定义为ESM规范,前端社区正逐渐向ESM标准迁移，从Node v12.0.0开始，只要设置了 <code>&quot;type&quot;: &quot;module&quot;</code>, Node 会将整个项目视为ESM规范，我们就可以直接写裸写<code>import/export</code>。</p><p><code>publishConfig.access</code>表示当前项目发布到NPM的访问级别，它有 <code>restricted</code>和<code>public</code>两个选项,<code>restricted</code>表示我们发布到NPM上的是私有包（收费），访问级别默认为<code>restricted</code>,因为我们是开源项目所以标记为<code>public</code>。</p><h2 id="配置">配置</h2><p>创建项目之后，我们开始安装工程化相关的依赖，因为我们是 TypeScript 项目，所以也需要安装 TypeScript 的依赖。</p><h3 id="typescript">Typescript</h3><p>先安装 TypeScript，然后使用 <code>tsc</code> 命名生成 <code>tsconfig.json</code>。</p><div class="language-auto"><pre><code>npm i typescript -D\nnpx tsc --init\n</code></pre></div><p>然后我们需要添加修改 <code>tsconfig.json</code> 的配置项，如下：</p><div class="language-auto"><pre><code>{\n  &quot;compilerOptions&quot;: {\n    /* Basic Options */\n    &quot;baseUrl&quot;: &quot;.&quot;, // 模块解析根路径，默认为 tsconfig.json 位于的目录\n    &quot;rootDir&quot;: &quot;src&quot;, // 编译解析根路径，默认为 tsconfig.json 位于的目录\n    &quot;target&quot;: &quot;ESNEXT&quot;, // 指定输出 ECMAScript 版本，默认为 es5\n    &quot;module&quot;: &quot;ESNext&quot;, // 指定输出模块规范，默认为 Commonjs\n    &quot;lib&quot;: [&quot;ESNext&quot;, &quot;DOM&quot;], // 编译需要包含的 API，默认为 target 的默认值\n    &quot;outDir&quot;: &quot;dist&quot;, // 编译输出文件夹路径，默认为源文件同级目录\n    &quot;sourceMap&quot;: true, // 启用 sourceMap，默认为 false\n    &quot;declaration&quot;: true, // 生成 .d.ts 类型文件，默认为 false\n    &quot;declarationDir&quot;: &quot;dist/types&quot;, // .d.ts 类型文件的输出目录，默认为 outDir 目录\n    /* Strict Type-Checking Options */\n    &quot;strict&quot;: true, // 启用所有严格的类型检查选项，默认为 true\n    &quot;esModuleInterop&quot;: true, // 通过为导入内容创建命名空间，实现 CommonJS 和 ES 模块之间的互操作性，默认为 true\n    &quot;skipLibCheck&quot;: true, // 跳过导入第三方 lib 声明文件的类型检查，默认为 true\n    &quot;forceConsistentCasingInFileNames&quot;: true, // 强制在文件名中使用一致的大小写，默认为 true\n    &quot;moduleResolution&quot;: &quot;Node&quot;, // 指定使用哪种模块解析策略，默认为 Classic\n  },\n  &quot;include&quot;: [&quot;src&quot;] // 指定需要编译文件，默认当前目录下除了 exclude 之外的所有.ts, .d.ts,.tsx 文件\n} \n</code></pre></div><p>更多详细配置参考：<a href="http://www.typescriptlang.org/tsconfig" target="_blank" rel="noopener noreferrer">www.typescriptlang.org/tsconfig</a></p><p>注意的点，如果你的项目涉及到<code>WebWorker API</code>，需要添加到 <code>lib</code> 字段中</p><div class="language-auto"><pre><code>&quot;lib&quot;: [&quot;ESNext&quot;, &quot;DOM&quot;, &quot;WebWorker&quot;],\n</code></pre></div><p>然后我们将编译后的文件路径添加到 <code>package.json</code>，并在 <code>scripts</code> 中添加编译命令。</p><div class="language-auto"><pre><code>-  &quot;main&quot;: &quot;index.js&quot;,\n+  &quot;main&quot;: &quot;dist/index.js&quot;,\n+  &quot;types&quot;: &quot;dist/types/index.d.ts&quot;\n   &quot;type&quot;: &quot;module&quot;,\n-   &quot;scripts&quot;: {\n-     &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n-   },\n+   &quot;scripts&quot;: {\n+     &quot;dev&quot;: &quot;tsc --watch&quot;,\n+     &quot;build&quot;: &quot;npm run clean &amp;&amp; tsc&quot;,\n+     &quot;clean&quot;: &quot;rm -rf dist&quot;\n+  },\n   &quot;publishConfig&quot;: {\n     &quot;access&quot;: &quot;public&quot;\n   }\n</code></pre></div><p><code>types</code> 配置项是指定编译生成的类型文件，如果 <code>compilerOptions.declarationDir</code> 指定的是<code>dist</code>，也就是源码和 <code>.d.ts</code> 同级，那么<code>types</code>可以省略。</p><p>验证配置是否生效，在 <code>index.ts</code> 写入</p><div class="language-auto"><pre><code>const calc = (a: number, b: number) =&gt; {\n  return a - b\n}\nconsole.log(calc(1024, 28))\n</code></pre></div><p>在控制台中执行</p><div class="language-auto"><pre><code>npm run build &amp;&amp; node dist/index.js\n</code></pre></div><p>会在 <code>dist</code> 目录中生成 <code>types/index.d.ts</code>、<code>index.js</code>、<code>index.js.map</code>，并打印 <code>996</code>。</p><h3 id="eslint-prettier">Eslint &amp; Prettier</h3><p>代码规范离不开各种 <code>Linter</code>, 之所以把这两个放在一起讲，借用 <code>Prettier</code> 官网的一句话：“使用 Prettier 解决代码格式问题，使用 linters 解决代码质量问题”。虽然<code>eslint</code>也有格式化功能，但是<code>prettier</code>的格式化功能更强大。</p><p>大部分同学编辑器都装了prettier-vscode和eslint-vscode这两个插件，如果你项目只有其中一个的配置，因为这两者部分格式化的功能有差异，那么就会造成一个的问题，代码分别被两个插件分别格式化一次，网上解决<code>prettier</code>+<code>eslint</code>冲突的方案五花八门，甚至还有把整个<code>rules</code>列表贴出来的。</p><p>那这里我们按照官方推荐，用最少的配置去解决<code>prettier</code>和<code>eslint</code>的集成问题。</p><h4 id="eslint">Eslint</h4><p>首先安装 <code>eslint</code>，然后利用 <code>eslint</code> 的命令行工具生成基本配置。</p><div class="language-auto"><pre><code>npm i eslint -D\nnpx eslint --init\n</code></pre></div><p>执行上面命令后会提示一些选项，我们依次选择符合我们项目的配置。</p><p>注意，这里 <code>eslint</code> 推荐了三种社区主流的规范，Airbnb、Standard、Google，因个人爱好我选择了不写分号的 Standard规范。</p><p>生成的<code>.eslintrc.cjs</code>文件应该长这样</p><div class="language-auto"><pre><code>module.exports = {\n  env: {\n    browser: true,\n    es2021: true,\n    node: true\n  },\n  extends: [\n    &#39;standard&#39;\n  ],\n  parser: &#39;@typescript-eslint/parser&#39;,\n  parserOptions: {\n    ecmaVersion: 12,\n    sourceType: &#39;module&#39;\n  },\n  plugins: [\n    &#39;@typescript-eslint&#39;\n  ],\n  rules: {\n  }\n}\n</code></pre></div><p>有些同学可能就要问了，这里为什么生成的配置文件名称是<code>.eslintrc.cjs</code>而不是<code>.eslintrc.js</code>？</p><p>因为我们将项目定义为<code>ESM</code>，<code>eslit --init</code>会自动识别<code>type</code>，并生成兼容的配置文件名称，如果我们改回<code>.js</code>结尾，再运行<code>eslint</code>将会报错。出现这个问题是<code>eslint</code>内部使用了<code>require()</code>语法读取配置。</p><p>同样，这个问题也适用于其他功能的配置，比如后面会讲到的<code>Prettier</code>、<code>Commitlint</code>等，配置文件都不能以<code>xx.js</code>结尾，而要改为当前库支持的其他配置文件格式，如：<code>.xxrc</code>、<code>.xxrc.json</code>、<code>.xxrc.yml</code>。</p><p>验证配置是否生效，修改<code>index.ts</code></p><div class="language-auto"><pre><code>  const calc = (a: number, b: number) =&gt; {\n    return a - b\n  }\n- console.log(calc(1024, 28))\n+ // console.log(calc(1024, 28))\n</code></pre></div><p>在<code>package.json</code>中添加<code>lint</code>命令</p><div class="language-auto"><pre><code>  &quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;tsc --watch&quot;,\n    &quot;build&quot;: &quot;npm run clean &amp;&amp; tsc&quot;,\n+   &quot;lint&quot;: &quot;eslint src --ext .js,.ts --cache --fix&quot;,\n    &quot;clean&quot;: &quot;rm -rf dist&quot;\n  },\n</code></pre></div><p>然后在控制台执行 <code>lint</code>,<code>eslint</code>将会提示 1 条错误信息，说明校验生效。</p><div class="language-auto"><pre><code>npm run lint\n# 1:7  error  &#39;calc&#39; is assigned a value but never used  no-unused-vars\n</code></pre></div><p>因为是 Typescript 项目所以我们还要添加Standard规范提供的 TypeScrip 扩展配置(其他规范同理)</p><p>安装eslint-config-standard-with-typescript</p><div class="language-auto"><pre><code>npm i eslint-config-standard-with-typescript -D\n</code></pre></div><p>添加修改 <code>.eslintrc.cjs</code></p><div class="language-auto"><pre><code>    module.exports = {\n      env: {\n        browser: true,\n        es2021: true,\n        node: true\n      },\n-     extends: [&#39;standard&#39;]\n+     extends: [&#39;standard&#39;, &#39;eslint-config-standard-with-typescript&#39;],\n      parser: &#39;@typescript-eslint/parser&#39;,\n      parserOptions: {\n        ecmaVersion: 12,\n        sourceType: &#39;module&#39;,\n+       project: &#39;./tsconfig.json&#39;\n      },\n      plugins: [&#39;@typescript-eslint&#39;],\n      rules: {}\n    }\n\n</code></pre></div><p>验证配置是否生效</p><p>在控制台执行<code>lint</code>,<code>eslint</code>将会提示 2 条错误信息，说明校验生效。</p><div class="language-auto"><pre><code>npm run lint\n# 1:7  error  &#39;calc&#39; is assigned a value but never used  no-unused-vars\n# 1:14 error  Missing return type on function \n</code></pre></div><h4 id="prettier">Prettier</h4><p>现在我们按照官网的推荐方式，把 <code>prettier</code> 集成到 <code>eslint</code> 的校验中。</p><p>安装 <code>prettier</code> 并初始化配置文件</p><div class="language-auto"><pre><code>npm i prettier -D\necho {}&gt; .prettierrc.json\n</code></pre></div><p>然后在<code>.prettierrc.json</code>添加配置，这里只需要添加和你所选规范冲突的部分。</p><div class="language-auto"><pre><code>{\n  &quot;semi&quot;: false, // 是否使用分号\n  &quot;singleQuote&quot;: true, // 使用单引号代替双引号\n  &quot;trailingComma&quot;: &quot;none&quot; // 多行时尽可能使用逗号结尾\n}\n</code></pre></div><p>更多配置详见：<a href="http://prettier.io/docs/en/opt%E2%80%A6" target="_blank" rel="noopener noreferrer">prettier.io/docs/en/opt…</a></p><p>安装解决冲突需要用到的两个依赖</p><ul><li><p>eslint-config-prettier 关闭可能与 <code>prettier</code> 冲突的规则</p></li><li><p>eslint-plugin-prettier 使用 <code>prettier</code> 代替 <code>eslint</code> 格式化</p></li></ul><div class="language-auto"><pre><code>npm i eslint-config-prettier eslint-plugin-prettier -D\n</code></pre></div><p>再添加修改 <code>.eslintrc.cjs</code>，如下：</p><div class="language-auto"><pre><code>  module.exports = {\n  env: {\n    browser: true,\n    es2021: true,\n    node: true,\n  },\n- extends: [&#39;standard&#39;, &#39;eslint-config-standard-with-typescript&#39;],\n+ extends: [&#39;standard&#39;, &#39;eslint-config-standard-with-typescript&#39;, &#39;prettier&#39;],\n  parser: &#39;@typescript-eslint/parser&#39;,\n  parserOptions: {\n    ecmaVersion: 12,\n    sourceType: &#39;module&#39;,\n    project: &#39;./tsconfig.json&#39;,\n  },\n- plugins: [&#39;@typescript-eslint&#39;],\n+ plugins: [&#39;@typescript-eslint&#39;, &#39;prettier&#39;],\n- rules: {},\n+ rules: {\n+   &#39;prettier/prettier&#39;: &#39;error&#39;\n+ },\n}\n</code></pre></div><p>然后验证配置是否生效，修改<code>index.ts</code></p><div class="language-auto"><pre><code>-  const calc = (a: number, b: number) =&gt; {\n+  const calc = (a: number, b: number): number =&gt; {\n    return a - b\n  }\n- // console.log(calc(1024, 28))\n+ console.log(calc(1024, 28))\n</code></pre></div><p>然后在控制台执行<code>lint</code>,这里<code>prettier</code>和<code>eslint</code>的行为已保持一致，如果没有报错，那就成功了。</p><div class="language-auto"><pre><code>npm run lint\n</code></pre></div><p>我们现在已经完成了<code>eslint</code>和<code>prettier</code>的集成配置。和编辑器无关，也就是说无论你使用什么编辑器，有没有安装相关插件，都不会影响代码校验的效果。</p><h3 id="husky">Husky</h3><p>因为一个项目通常是团队合作，我们不能保证每个人在提交代码之前执行一遍<code>lint</code>校验，所以需要<code>git hooks</code> 来自动化校验的过程，否则禁止提交。</p><p>安装<code>Husky</code>并生成<code>.husky</code>文件夹</p><div class="language-auto"><pre><code>npm i husky -D\nnpx husky install\n</code></pre></div><p>然后我们需要在每次执行<code>npm install</code>时自动启用<code>husky</code></p><p>如果你的<code>npm</code>版本大于等于<code>7.1.0</code></p><div class="language-auto"><pre><code>npm set-script prepare &quot;husky install&quot;\n</code></pre></div><p>否则手动在<code>package.json</code>中添加</p><div class="language-auto"><pre><code> &quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;tsc --watch&quot;,\n    &quot;build&quot;: &quot;npm run clean &amp;&amp; tsc&quot;,\n    &quot;lint&quot;: &quot;eslint src --ext .js,.ts --cache --fix&quot;,\n    &quot;clean&quot;: &quot;rm -rf dist&quot;,\n+   &quot;prepare&quot;: &quot;husky install&quot;\n  },\n</code></pre></div><p>然后添加一个<code>lint</code>钩子</p><div class="language-auto"><pre><code>npx husky add .husky/pre-commit &quot;npm run lint&quot;\n</code></pre></div><p>相当于手动在<code>.husky/pre-commit</code>文件写入以下内容：</p><div class="language-auto"><pre><code>#!/bin/sh\n. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;\nnpm run lint\n</code></pre></div><p>测试钩子是否生效，修改<code>index.ts</code></p><div class="language-auto"><pre><code>  const calc = (a: number, b: number): number =&gt; {\n    return a - b\n  }\n- console.log(calc(1024, 28))\n+ // console.log(calc(1024, 28))\n</code></pre></div><p>然后提交一条<code>commit</code>,如果配置正确将会自动执行<code>lint</code>并提示 1 条错误信息，<code>commit</code>提交将会失败。</p><div class="language-auto"><pre><code>git add .\ngit commit -m &#39;test husky&#39;\n# 1:7  error  &#39;calc&#39; is assigned a value but never used\n</code></pre></div><h3 id="commitlint">Commitlint</h3><p>为什么需要 <code>Commitlint</code>，除了在后续的生成<code>changelog</code>文件和语义发版中需要提取<code>commit</code>中的信息，也利于其他同学分析你提交的代码，所以我们要约定<code>commit</code>的规范。</p><p>安装 <code>Commitlint</code></p><ul><li><p>@commitlint/cli Commitlint 命令行工具</p></li><li><p>@commitlint/config-conventional 基于 Angular 的约定规范</p></li></ul><div class="language-auto"><pre><code>npm i @commitlint/config-conventional @commitlint/cli -D\n</code></pre></div><p>最后将<code>Commitlint</code>添加到钩子</p><div class="language-auto"><pre><code>npx husky add .husky/commit-msg &#39;npx --no-install commitlint --edit &quot;$1&quot;&#39;\n</code></pre></div><p>创建<code>.commitlintrc</code>，并写入配置</p><div class="language-auto"><pre><code>{\n  &quot;extends&quot;: [\n    &quot;@commitlint/config-conventional&quot;\n  ]\n}\n</code></pre></div><p>注意，这里配置文件名使用的是<code>.commitlintrc</code>而不是默认的<code>.commitlintrc.js</code>，详见 Eslint 章节</p><p>测试钩子是否生效，修改<code>index.ts</code>，让代码正确</p><div class="language-auto"><pre><code>  const calc = (a: number, b: number): void =&gt; {\n    console.log(a - b)\n  }\n- // calc(1024, 28)\n+ calc(1024, 28)\n</code></pre></div><p>提交一条不符合规范的<code>commit</code>，提交将会失败</p><div class="language-auto"><pre><code>git add .\ngit commit -m &#39;add eslint and commitlint&#39;\n</code></pre></div><p>修改为正确的<code>commit</code>，提交成功！</p><div class="language-auto"><pre><code>git commit -m &#39;ci: add eslint and commitlint&#39;\n</code></pre></div><p><em>Angular 规范说明：</em></p><ul><li><p><em>feat</em>：新功能</p></li><li><p><em>fix</em>：修补 BUG</p></li><li><p><em>docs</em>：修改文档，比如 README, CHANGELOG, CONTRIBUTE 等等</p></li><li><p><em>style</em>：不改变代码逻辑 (仅仅修改了空格、格式缩进、逗号等等)</p></li><li><p><em>refactor</em>：重构（既不修复错误也不添加功能）</p></li><li><p><em>perf</em>：优化相关，比如提升性能、体验</p></li><li><p><em>test</em>：增加测试，包括单元测试、集成测试等</p></li><li><p><em>build</em>：构建系统或外部依赖项的更改</p></li><li><p><em>ci</em>：自动化流程配置或脚本修改</p></li><li><p><em>chore</em>：非 src 和 test 的修改，发布版本等</p></li><li><p><em>revert</em>：恢复先前的提交</p></li></ul><h3 id="jest">Jest</h3><p><em>美好生活从测试覆盖率 100% 开始。</em></p><p>安装<code>jest</code>，和类型声明<code>@types/jest</code>，它执行需要<code>ts-node</code>和<code>ts-jest</code></p><p>这里暂时固定了<code>ts-node</code>的版本为 <code>v9.1.1</code>，新版的<code>ts-node@v10.0.0</code>会导致<code>jest</code>报错，等待官方修复，详见：issues</p><div class="language-auto"><pre><code>npm i jest @types/jest ts-node@9.1.1 ts-jest -D\n</code></pre></div><p>初始化配置文件</p><div class="language-auto"><pre><code>npx jest --init\n</code></pre></div><p>然后修改<code>jest.config.ts</code>文件</p><div class="language-auto"><pre><code>   // A preset that is used as a base for Jest&#39;s configuration\n-  // preset: undefined,\n+  preset: &#39;ts-jest&#39;\n</code></pre></div><p>将测试命令添加到<code>package.json</code>中。</p><div class="language-auto"><pre><code>  &quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;tsc --watch&quot;,\n    &quot;build&quot;: &quot;npm run clean &amp;&amp; tsc&quot;,\n    &quot;lint&quot;: &quot;eslint src --ext .js,.ts --cache --fix&quot;,\n    &quot;clean&quot;: &quot;rm -rf dist&quot;,\n    &quot;prepare&quot;: &quot;husky install&quot;,\n+   &quot;test&quot;: &quot;jest&quot;\n  },\n</code></pre></div><p>创建测试文件夹<code>__tests__</code>和测试文件<code>__tests__/calc.spec.ts</code></p><p>修改<code>index.ts</code></p><div class="language-auto"><pre><code>  const calc = (a: number, b: number): number =&gt; {\n    return a - b\n  }\n- // console.log(calc(1024, 28))\n+ export default calc\n</code></pre></div><p>然后在<code>calc.spec.ts</code>中写入测试代码</p><div class="language-auto"><pre><code>import calc from &#39;../src&#39;\n\ntest(&#39;The calculation result should be 996.&#39;, () =&gt; {\n  expect(calc(1024, 28)).toBe(996)\n})\n</code></pre></div><p>验证配置是否生效</p><p>在控制台执行<code>test</code>，将会看到测试覆盖率 100% 的结果。</p><div class="language-auto"><pre><code>npm run test\n</code></pre></div><p>最后我们给<code>__tests__</code>目录也加上<code>lint</code>校验</p><p>修改<code>package.json</code></p><div class="language-auto"><pre><code>  &quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;tsc --watch&quot;,\n    &quot;build&quot;: &quot;npm run clean &amp;&amp; tsc&quot;,\n-   &quot;lint&quot;: &quot;eslint src --ext .js,.ts --cache --fix&quot;,\n+   &quot;lint&quot;: &quot;eslint src __tests__ --ext .js,.ts --cache --fix&quot;,\n    &quot;clean&quot;: &quot;rm -rf dist&quot;,\n    &quot;prepare&quot;: &quot;husky install&quot;,\n    &quot;test&quot;: &quot;jest&quot;\n  },\n</code></pre></div><p>这里如果我们直接执行<code>npm run lint</code>将会报错，提示<code>__tests__</code>文件夹没有包含在<code>tsconfig.json</code>的<code>include</code>中，当我们添加到<code>include</code>之后，输出的<code>dist</code>中就会包含测试相关的文件，这并不是我们想要的效果。</p><p>我们使用<code>typescript-eslint</code>官方给出的解决方案，如下操作：</p><p>新建一个<code>tsconfig.eslint.json</code>文件，写入以下内容：</p><div class="language-auto"><pre><code>{\n  &quot;extends&quot;: &quot;./tsconfig.json&quot;,\n  &quot;include&quot;: [&quot;**/*.ts&quot;, &quot;**/*.js&quot;]\n}\n</code></pre></div><p>在<code>.eslintrc.cjs</code>中修改</p><div class="language-auto"><pre><code>  parserOptions: {\n    ecmaVersion: 12,\n    sourceType: &#39;module&#39;,\n-   project: &#39;./tsconfig.json&#39;\n+   project: &#39;./tsconfig.eslint.json&#39;\n  },\n</code></pre></div><p>然后验证配置是否生效，直接提交我们添加的测试文件,能正确提交说明配置成功。</p><div class="language-auto"><pre><code>git add .\ngit commit -m &#39;test: add unit test&#39;\n</code></pre></div><h3 id="github-actions">Github Actions</h3><p>我们通过<code>Github Actions</code>实现代码合并或推送到主分支，<code>dependabot</code>机器人升级依赖等动作，会自动触发测试和发布版本等一系列流程。</p><p>在项目根目录创建<code>.github/workflows</code>文件夹，然后在里面新建<code>ci.yml</code>文件和<code>cd.yml</code>文件</p><p>在<code>ci.yml</code>文件中写入：</p><div class="language-auto"><pre><code>name: CI\n\non:\n  push:\n    branches:\n      - &#39;**&#39;\n  pull_request:\n    branches:\n      - &#39;**&#39;\njobs:\n  linter:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v2\n        with:\n          node-version: 16\n      - run: npm ci\n      - run: npm run lint\n  tests:\n    needs: linter\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v2\n        with:\n          node-version: 16\n      - run: npm ci\n      - run: npm run test\n\n</code></pre></div><p>上面配置大概意思就是，监听所有分支的<code>push</code>和<code>pull_request</code>动作，自动执行<code>linter</code>和<code>tests</code>任务。</p><p>GithubActions 更多用法参考：<a href="http://github.com/features/ac%E2%80%A6" target="_blank" rel="noopener noreferrer">github.com/features/ac…</a></p><p>然后推送代码，验证配置是否生效</p><div class="language-auto"><pre><code>git add .\ngit commit -m &#39;ci: use github actions&#39;\ngit push\n</code></pre></div><p>此时打开当前项目的 <em>Github</em> 页面，然后点击顶部 <em>Actions</em> 菜单就会看到正在进行的两个任务，一个将会成功（测试），一个将会失败（发布）。</p><p>上面只是实现了代码自动测试流程，下面实现自动发布的流程。</p><p>在此之前需要到NPM网站上注册一个账号（已有可忽略），并创建一个<code>package</code>。</p><p>然后创建<code>GH_TOKEN</code>和<code>NPM_TOKEN</code>（注意，不要在代码中包含任何的 TOKEN 信息）：</p><ul><li><p>如何创建 GITHUB\\_TOKEN（创建时勾选 <em>repo</em> 和 <em>workflow</em> 权限）</p></li><li><p>如何创建 NPM\\_TOKEN（创建时选中 <em>Automation</em> 权限）</p></li></ul><p>将创建好的两个<code>TOKEN</code>添加到项目的 <em>Actions secrets</em> 中：</p><p><em>Github 项目首页</em> -&gt; <em>顶部 Settings 菜单</em> -&gt; <em>侧边栏 Secrets</em></p><p>然后修改<code>package.json</code>中的<code>“name”</code>，<code>“name”</code>就是你在NPM上创建的<code>package</code>的名称。</p><p>在<code>cd.yml</code>文件中写入：</p><div class="language-auto"><pre><code>name: CD\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v2\n        with:\n          node-version: 16\n      # https://github.com/semantic-release/git/issues/209\n      - run: npm ci --ignore-scripts\n      - run: npm run build\n      - run: npx semantic-release\n        env:\n          GH_TOKEN: ${{ secrets.GH_TOKEN }}\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n</code></pre></div><p>由于“黑命贵”，Github 已将新项目的默认分支名称更改为 <code>“main”</code>，详见：issues， 为了方便，后面统一称为 <em>主分支</em></p><p>所以如果你的主分支名称是<code>“main”</code>，上面的<code>branches</code>需要修改为：</p><div class="language-auto"><pre><code>on:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n</code></pre></div><p>然后安装语义发版依赖，需要用到<code>semantic-release</code>和它的插件：</p><ul><li><p>semantic-release：语义发版核心库</p></li><li><p>@semantic-release/changelog：用于自动生成 <a href="http://changelog.md" target="_blank" rel="noopener noreferrer">changelog.md</a></p></li><li><p>@semantic-release/git：用于将发布时产生的更改提交回远程仓库</p></li></ul><div class="language-auto"><pre><code>npm i semantic-release @semantic-release/changelog @semantic-release/git -D\n</code></pre></div><p>在项目根目录新建配置文件<code>.releaserc</code>并写入：</p><div class="language-auto"><pre><code>{\n  &quot;branches&quot;: [&quot;master&quot;],\n  &quot;plugins&quot;: [\n    &quot;@semantic-release/commit-analyzer&quot;,\n    &quot;@semantic-release/release-notes-generator&quot;,\n    &quot;@semantic-release/changelog&quot;,\n    &quot;@semantic-release/github&quot;,\n    &quot;@semantic-release/npm&quot;,\n    &quot;@semantic-release/git&quot;\n  ]\n}\n</code></pre></div><p>这里同样，如果你的主分支名称是<code>“main”</code>，上面的<code>branches</code>需要修改为：</p><div class="language-auto"><pre><code>  &quot;branches&quot;: [&quot;+([0-9])?(.{+([0-9]),x}).x&quot;, &quot;main&quot;],\n</code></pre></div><p>最后新建分支 <em>develop</em> 分支并提交工作内容。</p><div class="language-auto"><pre><code>git checkout -b develop\ngit add .\ngit commit -m &#39;feat: complete the CI/CD workflow&#39;\ngit push --set-upstream origin develop\ngit push\n</code></pre></div><p>然后将 <em>develop</em> 分支合并到 <em>主分支</em>，并提交，注意：这个提交会触发测试并 <em>发布版本</em> (自动创建<code>tag</code>和<code>changelog</code>)</p><div class="language-auto"><pre><code>git checkout master\ngit merge develop\ngit push\n</code></pre></div><p>完成上面操作之后，打开 <em>Github 项目主页</em> 和 <em>NPM 项目主页</em> 可以看到一个 <em>Release</em> 的更新记录。</p><p>最后切回到 <em>develop</em> 分支，创建一个自动更新依赖的<code>workflow</code>。</p><p>在<code>.github</code>文件夹中创建<code>dependabot.yml</code>文件，并写入内容：</p><div class="language-auto"><pre><code>version: 2\nupdates:\n  # Enable version updates for npm\n  - package-ecosystem: &#39;npm&#39;\n    # Look for `package.json` and `lock` files in the `root` directory\n    directory: &#39;/&#39;\n    # Check the npm registry for updates every day (weekdays)\n    schedule:\n      interval: &#39;weekly&#39;\n</code></pre></div><p>提交并查看 <em>workflows</em> 是否全部通过，再合并到 <em>主分支</em> 并提交，这个提交不会触发版本发布。</p><div class="language-auto"><pre><code>git pull origin master\ngit add .\ngit commit -m &#39;ci: add dependabot&#39;\ngit push \n\ngit checkout master\ngit merge develop\ngit push\n</code></pre></div><p>触发版本发布需要两个条件：</p><ol><li><p>只有当<code>push</code>和<code>pull_request</code>到 <em>主分支</em> 上才会触发版本发布</p></li><li><p>只有<code>commit</code>前缀为<code>feat</code>、<code>fix</code>、<code>perf</code>才会发布，否则跳过。</p></li></ol><p>更多发布规则，详见：<a href="http://github.com/semantic-re%E2%80%A6" target="_blank" rel="noopener noreferrer">github.com/semantic-re…</a></p><p>SemanticRelease 使用方式，详见：<a href="http://semantic-release.gitbook.io" target="_blank" rel="noopener noreferrer">semantic-release.gitbook.io</a></p><p><strong>如果你能正确配置上面所有步骤，并成功发布，那么恭喜你！你拥有了一个完全自动化的项目，它拥有：自动依赖更新、测试、发布，和自动生成版本信息等功能。</strong></p><p>完整的项目示例：@resreq/event-hub</p><h2 id="结语">结语</h2><p>本文未涉及到：组件库、Monorepo、Jenkins CI 等配置，但能覆盖绝大部前端项目 CI/CD 流程。</p><p>有些地方讲得比较细，甚至有些啰嗦，但还是希望能帮助到大家！撒花！🎉🎉🎉</p><p><img src="https://qn.huat.xyz/mac/20220716185154.png" alt=""></p><p><strong>程序员成长指北</strong></p><p>专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师。一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。</p><p>94篇原创内容</p><p>公众号</p><p>Node 社群</p><p>我组建了一个氛围特别好的 Node.js 社群，里面有很多 Node.js小伙伴，如果你对Node.js学习感兴趣的话（后续有计划也可以），我们可以一起进行Node.js相关的交流、学习、共建。下方加 考拉 好友回复「Node」即可。</p>',208)];c.render=function(t,n,c,s,i,p){return e(),o("div",null,d)};export default c;export{n as __pageData};
