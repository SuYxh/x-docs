import{o as e,c as o,e as t}from"./app.c30441d1.js";const d='{"title":"环境搭建","description":"","frontmatter":{},"headers":[{"level":2,"title":"环境搭建","slug":"环境搭建"},{"level":2,"title":"ref()","slug":"ref"},{"level":3,"title":"类型定义","slug":"类型定义"},{"level":3,"title":"为 ref() 标注类型","slug":"为-ref-标注类型"},{"level":3,"title":"三种方式推荐","slug":"三种方式推荐"},{"level":2,"title":"reactive()","slug":"reactive"},{"level":3,"title":"类型定义","slug":"类型定义-1"},{"level":3,"title":"为 reactive() 标注类型","slug":"为-reactive-标注类型"},{"level":3,"title":"两种方式推荐","slug":"两种方式推荐"},{"level":2,"title":"computed ()","slug":"computed"},{"level":3,"title":"类型定义","slug":"类型定义-2"},{"level":3,"title":"为 computed() 标注类型","slug":"为-computed-标注类型"},{"level":3,"title":"两种方式推荐","slug":"两种方式推荐-1"},{"level":2,"title":"defineProps()","slug":"defineprops"},{"level":3,"title":"为 defineProps() 标注类型","slug":"为-defineprops-标注类型"},{"level":2,"title":"defineEmits()","slug":"defineemits"},{"level":3,"title":"为 defineEmits() 标注类型","slug":"为-defineemits-标注类型"},{"level":2,"title":"defineExpose()","slug":"defineexpose"},{"level":3,"title":"为 defineExpose() 标注类型","slug":"为-defineexpose-标注类型"},{"level":2,"title":"provide()","slug":"provide"},{"level":3,"title":"类型定义","slug":"类型定义-3"},{"level":3,"title":"为 provide() 标注类型","slug":"为-provide-标注类型"},{"level":2,"title":"inject()","slug":"inject"},{"level":3,"title":"类型定义","slug":"类型定义-4"},{"level":3,"title":"为 inject() 标注类型","slug":"为-inject-标注类型"},{"level":2,"title":"模板 ref","slug":"模板-ref"},{"level":2,"title":"组件 ref","slug":"组件-ref"},{"level":2,"title":"事件处理器","slug":"事件处理器"},{"level":2,"title":"写在最后","slug":"写在最后"}],"relativePath":"framework/vue-article/最详细的 Vue3 + TypeScript 使用教程.md","lastUpdated":1661330957047}',c={},n=[t('<p>点击下方“前端开发爱好者”，选择“设为星标”</p><p>第一时间关注技术干货！</p><p><img src="https://qn.huat.xyz/mac/20220725204331.png" alt=""></p><p><strong>前端开发爱好者</strong></p><p>分享 web 前端相关技术文章、工具资源、精选课程、视频教程资源、热点资讯</p><p>60篇原创内容</p><p>公众号</p><blockquote><p>哈喽,大家好 我是<code>xy</code>👨🏻‍💻。最近技术栈刚刚由之前的 <code>React</code> 转向 <code>Vue3</code>了，由于之前多多少少也接触过 <code>Vue</code>，所以这次只用了一个上午的时间就上手 <code>Vue3</code> 了，如果大家有关于<code>vue</code>或者<code>react</code>上的问题，欢迎来滴滴我，一起交流学习 💪</p></blockquote><p>至于技术栈为什么由 <code>react</code> 转向 <code>vue3</code>，也是因为今年换了新工作，公司技术栈以<code>vue3</code>为主，刚好前段时间又接手了一个项目，就直接采用 <code>Vue3</code> <code>script setup</code> <code>typescript</code> 开发，于是今天就想给大家分享下 <code>script setup</code> 结合 <code>typescript</code> 使用的一些技巧，如果这些技巧能够帮助到你，记得给我点个赞呦 👍</p><h2 id="环境搭建">环境搭建</h2><p>环境搭建这里就不详细介绍了，可以直接使用官方的方式创建</p><div class="language-auto"><pre><code>npm init vue@latest\n</code></pre></div><p>这一指令将会安装并执行 <code>create-vue</code>，它是 <code>Vue</code> 官方的项目脚手架工具。你将会看到一些诸如 <code>TypeScript</code> 和<code>测试</code>支持之类的可选功能提示：</p><div class="language-auto"><pre><code>✔ Project name: … &lt;your-project-name&gt;\n✔ Add TypeScript? … No / Yes\n✔ Add JSX Support? … No / Yes\n✔ Add Vue Router for Single Page Application development? … No / Yes\n✔ Add Pinia for state management? … No / Yes\n✔ Add Vitest for Unit testing? … No / Yes\n✔ Add Cypress for both Unit and End-to-End testing? … No / Yes\n✔ Add ESLint for code quality? … No / Yes\n✔ Add Prettier for code formatting? … No / Yes\n\nScaffolding project in ./&lt;your-project-name&gt;...\nDone.\n</code></pre></div><p>如果不确定是否要开启某个功能，你可以直接按下回车键选择 <code>No</code>。在项目被创建后，通过以下步骤安装依赖并启动开发服务器：</p><div class="language-auto"><pre><code>cd &lt;your-project-name&gt;\nnpm install\nnpm run dev\n</code></pre></div><p>想看更多的<code>详细配置</code>的同学，可以移步到我之前的一篇文章中：<a href="http://mp.weixin.qq.com/s?__biz=MzUzNTk3MjE2Ng==&amp;mid=2247490197&amp;idx=1&amp;sn=df6b58af594299ffda15483df3c082c0&amp;chksm=fafc0abccd8b83aa2fb4371aa21dc4f1f0719697b123991b562709cf1920bc79f5452512f289&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer"><img src="https://qn.huat.xyz/mac/20220725204336.jpeg" alt="图片"></a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUzNTk3MjE2Ng==&amp;mid=2247490197&amp;idx=1&amp;sn=df6b58af594299ffda15483df3c082c0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer"></a></p><p>这里就不做过多的讲解了，这篇文章的重点还是在 <code>script setup</code> <code>typescript</code> 结合使用上</p><h2 id="ref">ref()</h2><p><code>ref()</code>接受一个内部值，返回一个响应式的、可更改的 <code>ref</code> 对象，此对象只有一个指向其内部值的 <code>property .value</code>。</p><h3 id="类型定义">类型定义</h3><div class="language-auto"><pre><code>function ref&lt;T&gt;(value: T): Ref&lt;UnwrapRef&lt;T&gt;&gt;\ninterface Ref&lt;T&gt; {\n  value: T\n}\n</code></pre></div><h3 id="为-ref-标注类型">为 ref() 标注类型</h3><p><code>ref()</code> 标注类型有三种方式：</p><ol><li>通过泛型参数的形式来给 <code>ref()</code>增加类型</li></ol><div class="language-auto"><pre><code>import { ref } from &#39;vue&#39;\n\nconst initCode = ref&lt;string | number&gt;(&#39;200&#39;)\n</code></pre></div><ol start="2"><li>如果是遇到复杂点的类型，可以自定义 <code>interface</code> 然后泛型参数的形式传入</li></ol><div class="language-auto"><pre><code>import { ref } from &#39;vue&#39;\n\ninterface User {\n  name: string\n  age: string | number\n}\n\nconst user = ref&lt;User&gt;({\n  name:&#39;前端开发爱好者&#39;,\n  age: 20\n})\n</code></pre></div><ol start="3"><li>通过使用 <code>Ref</code> 这个类型为 <code>ref</code> 内的值指定一个更复杂的类型</li></ol><div class="language-auto"><pre><code>import { ref } from &#39;vue&#39;\nimport type { Ref } from &#39;vue&#39;\n\nconst initCode: Ref&lt;string | number&gt; = ref(&#39;200&#39;)\n</code></pre></div><h3 id="三种方式推荐">三种方式推荐</h3><p>比较推荐使用<code>前两种</code>方式，前两种方式其实都是以<code>泛型</code>的形式来标注类型的</p><p>第三种方式需要额外的引入：</p><div class="language-auto"><pre><code>import type { Ref } from &#39;vue&#39;\n</code></pre></div><p>所以不是很推荐(本着能少写一行是一行原则)</p><h2 id="reactive">reactive()</h2><p><code>reactive()</code> 返回一个对象的响应式代理。</p><h3 id="类型定义-1">类型定义</h3><div class="language-auto"><pre><code>function reactive&lt;T extends object&gt;(target: T): UnwrapNestedRefs&lt;T&gt;\n</code></pre></div><h3 id="为-reactive-标注类型">为 reactive() 标注类型</h3><p><code>reactive()</code>标注类型有两种方式：</p><ol><li>直接给声明的变量添加类型</li></ol><div class="language-auto"><pre><code>import { reactive } from &#39;vue&#39;\n\ninterface User {\n  name: string\n  age: string | number\n}\n\nconst user:User = reactive({\n  name:&quot;前端开发爱好者&quot;,\n  age:&#39;20&#39;\n})\n</code></pre></div><ol start="2"><li>通过泛型参数的形式来给 <code>reactive()</code>增加类型</li></ol><div class="language-auto"><pre><code>import { reactive } from &#39;vue&#39;\n\ninterface User {\n  name: string\n  age: string | number\n}\n\nconst user = reactive&lt;User&gt;({\n  name:&quot;前端开发爱好者&quot;,\n  age:&#39;20&#39;\n})\n</code></pre></div><h3 id="两种方式推荐">两种方式推荐</h3><p><code>不推荐</code>使用 <code>reactive()</code> 的泛型参数,因为处理了深层次 ref 解包的返回值与泛型参数的类型不同。<code>推荐直接给声明的变量添加类型</code>。</p><h2 id="computed">computed ()</h2><p>接受一个 <code>getter</code> 函数，返回一个只读的响应式 <code>ref</code> 对象，即 <code>getter</code> 函数的返回值。它也可以接受一个带有 <code>get</code> 和 <code>set</code> 函数的对象来创建一个可写的 <code>ref</code> 对象。</p><h3 id="类型定义-2">类型定义</h3><div class="language-auto"><pre><code>// 只读\nfunction computed&lt;T&gt;(\n  getter: () =&gt; T,\n  debuggerOptions?: DebuggerOptions\n): Readonly&lt;Ref&lt;Readonly&lt;T&gt;&gt;&gt;\n\n// 可写的\nfunction computed&lt;T&gt;(\n  options: {\n    get: () =&gt; T\n    set: (value: T) =&gt; void\n  },\n  debuggerOptions?: DebuggerOptions\n): Ref&lt;T&gt;\n</code></pre></div><h3 id="为-computed-标注类型">为 computed() 标注类型</h3><p><code>computed()</code>标注类型有两种方式：</p><ol><li>从其计算函数的返回值上推导出类型</li></ol><div class="language-auto"><pre><code>import { ref, computed } from &#39;vue&#39;\n\nconst count = ref&lt;number&gt;(0)\n\n// 推导得到的类型：ComputedRef&lt;string&gt;\nconst user = computed(() =&gt; count.value + &#39;前端开发爱好者&#39;)\n</code></pre></div><ol start="2"><li>通过泛型参数显式指定 <code>computed()</code> 类型</li></ol><div class="language-auto"><pre><code>const user = computed&lt;string&gt;(() =&gt; {\n  // 若返回值不是 string 类型则会报错\n  return &#39;前端开发爱好者&#39;\n})\n</code></pre></div><h3 id="两种方式推荐-1">两种方式推荐</h3><p>自动推导类型虽然简单快捷，但是还是希望<code>手动</code>的去<code>指定</code>其类型，这样更加利于代码的可维护性，所以这里推荐大家使用通过泛型参数显式指定 <code>computed()</code> 类型</p><h2 id="defineprops">defineProps()</h2><p>为了在声明 <code>props</code> 选项时获得完整的类型推断支持，我们可以使用 <code>defineProps</code> API，它将自动地在 <code>script setup</code> 中使用</p><h3 id="为-defineprops-标注类型">为 defineProps() 标注类型</h3><ol><li>从它的参数中推导类型:</li></ol><div class="language-auto"><pre><code>const props = defineProps({\n  name: { type: String, required: true },\n  age: Number\n})\n</code></pre></div><ol start="2"><li>通过泛型参数来定义 <code>props</code> 的类型</li></ol><div class="language-auto"><pre><code>const props = defineProps&lt;{\n  name: string\n  age?: number\n}&gt;()\n</code></pre></div><p>当然了,我们也可以把以上的泛型参数定义成一个单独的 <code>interface</code></p><div class="language-auto"><pre><code>interface Props {\n  name: string\n  age?: number\n}\n\nconst props = defineProps&lt;Props&gt;()\n</code></pre></div><blockquote><p>以上的两种方式虽然都可以很方便的<code>标注类型</code>, 但是失去了对 <code>props</code> 定义默认值的能力</p></blockquote><p>目前官方也给出了解决方案,但是目前这个方案还处于实验性,并且需要<code>显式地选择开启</code>。</p><div class="language-auto"><pre><code>// vite.config.js\nexport default {\n  plugins: [\n    vue({\n      reactivityTransform: true\n    })\n  ]\n}\n</code></pre></div><p>通过对 <code>defineProps()</code> 的响应性解构来添加默认值:</p><div class="language-auto"><pre><code>&lt;script setup lang=&quot;ts&quot;&gt;\ninterface Props {\n  name: string\n  age?: number\n}\n\nconst { name = &#39;前端开发爱好者&#39;, age = 100 } = defineProps&lt;Props&gt;()\n&lt;/script&gt;\n</code></pre></div><h2 id="defineemits">defineEmits()</h2><p>为了在声明 <code>emits</code> 选项时获得完整的类型推断支持，我们可以使用 <code>defineEmits</code> API，它将自动地在 <code>script setup</code> 中使用</p><h3 id="为-defineemits-标注类型">为 defineEmits() 标注类型</h3><p><code>defineEmits()</code> 标注类型直接推荐<code>泛型</code>形式</p><div class="language-auto"><pre><code>import type { GlobalTheme } from &#39;naive-ui&#39;\n\nconst emit = defineEmits&lt;{\n  (e: &#39;setThemeColor&#39;, val: GlobalTheme): void\n}&gt;()\n</code></pre></div><p>虽然官方还推荐了<code>运行时</code>自动推导的一种形式,但是本人不是很推荐</p><h2 id="defineexpose">defineExpose()</h2><p><code>defineExpose()</code> 编译器宏来显式指定在 <code>script setup</code> 组件中要暴露出去的 <code>property</code>,使得父组件通过<code>模板ref</code>的方式获取到当前组件的实例</p><h3 id="为-defineexpose-标注类型">为 defineExpose() 标注类型</h3><p><code>defineExpose()</code> 类型推导直接使用参数类型自动推导即可</p><div class="language-auto"><pre><code>&lt;script setup&gt;\nimport { ref } from &#39;vue&#39;\n\nconst name = ref&lt;string&gt;(&#39;前端开发爱好者&#39;)\n\ndefineExpose({\n  name\n})\n</code></pre></div><h2 id="provide">provide()</h2><p><code>provide()</code>供给一个值，可以被后代组件注入</p><h3 id="类型定义-3">类型定义</h3><div class="language-auto"><pre><code>function provide&lt;T&gt;(key: InjectionKey&lt;T&gt; | string, value: T): void\n</code></pre></div><h3 id="为-provide-标注类型">为 provide() 标注类型</h3><p>为 <code>provide()</code> 标注类型, Vue 提供了一个 <code>InjectionKey</code> 接口，它是一个继承自 <code>Symbol</code> 的泛型类型，可以用来在提供者和消费者之间同步注入值的类型</p><div class="language-auto"><pre><code>import type { InjectionKey } from &#39;vue&#39;\n\n// 建议声明 key (name) 放到公共的文件中\n// 这样就可以在 inject 的时候直接导入使用\nconst name = Symbol() as InjectionKey&lt;string&gt;\n\nprovide(name, &#39;前端开发爱好者&#39;) // 若提供的是非字符串值会导致错误\n</code></pre></div><p>以上方式是通过定义 key 的类型来标注类型的,还有一种方式直接 <code>key</code> 采用<code>字符串</code>的形式添加</p><div class="language-auto"><pre><code>provide(&#39;name&#39;, &#39;前端开发爱好者&#39;)\n</code></pre></div><h2 id="inject">inject()</h2><p><code>inject()</code>注入一个由祖先组件或整个应用供给的值</p><h3 id="类型定义-4">类型定义</h3><div class="language-auto"><pre><code>// 没有默认值\nfunction inject&lt;T&gt;(key: InjectionKey&lt;T&gt; | string): T | undefined\n\n// 带有默认值\nfunction inject&lt;T&gt;(key: InjectionKey&lt;T&gt; | string, defaultValue: T): T\n\n// 使用工厂函数\nfunction inject&lt;T&gt;(\n  key: InjectionKey&lt;T&gt; | string,\n  defaultValue: () =&gt; T,\n  treatDefaultAsFactory: true\n): T\n</code></pre></div><h3 id="为-inject-标注类型">为 inject() 标注类型</h3><p><code>provide()</code> 的 <code>key</code> 的类型是声明式提供的话(provide()类型标注的第一种形式)</p><p><code>inject()</code> 可以直接导入声明的 <code>key</code> 来获取父级组件提供的值</p><div class="language-auto"><pre><code>// 由外部导入\nconst name = Symbol() as InjectionKey&lt;string&gt;\n\nconst injectName = inject(name)\n</code></pre></div><p>如果 <code>provide()</code> 的 <code>key</code> 直接使用的<code>字符串</code>形式添加的, 需要通过泛型参数声明</p><div class="language-auto"><pre><code>const injectName = inject&lt;string&gt;(&#39;name&#39;)\n</code></pre></div><h2 id="模板-ref">模板 ref</h2><p>模板 <code>ref</code> 需要通过一个显式指定的<code>泛型参数</code>和一个<code>初始值 null</code> 来创建：</p><div class="language-auto"><pre><code>&lt;img ref=&quot;el&quot; class=&quot;logo&quot; :src=&quot;Logo&quot; alt=&quot;&quot; /&gt;\n\nconst el = ref&lt;HTMLImageElement | null&gt;(null)\n</code></pre></div><h2 id="组件-ref">组件 ref</h2><p>有时，你可能需要为一个子组件添加一个模板 ref，以便调用它公开的方法</p><div class="language-auto"><pre><code>&lt;!-- Child.vue --&gt;\n&lt;script setup lang=&quot;ts&quot;&gt;\nconst handleLog = () =&gt; console.log(&#39;前端开发爱好者&#39;)\n\ndefineExpose({\n  open\n})\n&lt;/script&gt;\n</code></pre></div><p>为了获取 <code>MyModal</code> 的类型，我们首先需要通过 <code>typeof</code> 得到其类型，再使用 <code>TypeScript</code> 内置的 <code>InstanceType</code> 工具类型来获取其实例类型：</p><div class="language-auto"><pre><code>&lt;!-- parent.vue --&gt;\n&lt;script setup lang=&quot;ts&quot;&gt;\nimport Child from &#39;./Child.vue&#39;\n\n// 为子组件 ref 声明类型\nconst child = ref&lt;InstanceType&lt;typeof Child&gt; | null&gt;(null)\n\n// 调用子组件中的方法\nconst getChildHandleLog = () =&gt; {\n  child.value?.handleLog()\n}\n&lt;/script&gt;\n</code></pre></div><h2 id="事件处理器">事件处理器</h2><p>原生的 DOM 事件标注类型</p><div class="language-auto"><pre><code>&lt;template&gt;\n  &lt;input type=&quot;text&quot; @change=&quot;handleChange&quot; /&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=&quot;ts&quot;&gt;\nfunction handleChange(event: Event) {\n  console.log((event.target as HTMLInputElement).value)\n}\n&lt;/script&gt;\n</code></pre></div><h2 id="写在最后">写在最后</h2><blockquote><p><code>公众号</code>：<code>前端开发爱好者</code> 专注分享 <code>web</code> 前端相关<code>技术文章</code>、<code>视频教程</code>资源、热点资讯等，如果喜欢我的分享，给 🐟🐟 点一个<code>赞</code> 👍 或者 ➕<code>关注</code> 都是对我最大的支持。</p></blockquote><p>关注公众号后，在首页：</p><ul><li><p>回复<code>面试题</code>，获取最新大厂面试资料。</p></li><li><p>回复<code>简历</code>，获取 3200 套 简历模板。</p></li><li><p>回复<code>React实战</code>，获取 React 最新实战教程。</p></li><li><p>回复<code>Vue实战</code>，获取 Vue 最新实战教程。</p></li><li><p>回复<code>ts</code>，获取 TypeScript 精讲课程。</p></li><li><p>回复<code>vite</code>，获取 精讲课程。</p></li><li><p>回复<code>uniapp</code>，获取 uniapp 精讲课程。</p></li><li><p>回复<code>js书籍</code>，获取 js 进阶 必看书籍。</p></li><li><p>回复<code>Node</code>，获取 Nodejs+koa2 实战教程。</p></li><li><p>回复<code>数据结构算法</code>，获取数据结构算法教程。</p></li><li><p>回复<code>架构师</code>，获取 架构师学习资源教程。</p></li><li><p>更多教程资源应有尽有，欢迎<code>关注获取</code></p></li></ul>',119)];c.render=function(t,d,c,i,l,p){return e(),o("div",null,n)};export default c;export{d as __pageData};
