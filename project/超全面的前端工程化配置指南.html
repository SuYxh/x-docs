<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端工程化配置指南 | VitePress</title>
    <meta name="description" content="Life is short, Keep it simple.">
    <link rel="stylesheet" href="/x-docs/assets/style.5f411fd9.css">
    <link rel="modulepreload" href="/x-docs/assets/Home.322c3b55.js">
    <link rel="modulepreload" href="/x-docs/assets/AlgoliaSearchBox.bcb747ed.js">
    <link rel="modulepreload" href="/x-docs/assets/app.6a9dab50.js">
    <link rel="modulepreload" href="/x-docs/assets/project_超全面的前端工程化配置指南.md.e3106243.lean.js">
    <link rel="modulepreload" href="/x-docs/assets/app.6a9dab50.js">
    <link rel="icon" type="image/svg+xml" href="/logo.svg">
    <meta name="twitter:title" content="前端工程化配置指南 | VitePress">
    <meta property="og:title" content="前端工程化配置指南 | VitePress">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-675d8756><div class="sidebar-button" data-v-675d8756><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/x-docs/" aria-label="VitePress, back to home" data-v-675d8756 data-v-4a583abe><img class="logo" src="/x-docs/logo.svg" alt="Logo" data-v-4a583abe> VitePress</a><div class="flex-grow" data-v-675d8756></div><div class="nav" data-v-675d8756><nav class="nav-links" data-v-675d8756 data-v-15acbf05><!--[--><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/x-docs/basic/" data-v-b8818f8c>基础 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/x-docs/framework/index" data-v-b8818f8c>框架 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/x-docs/project/" data-v-b8818f8c>工程化 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/x-docs/node/" data-v-b8818f8c>Node <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/x-docs/weixin/" data-v-b8818f8c>微信相关 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/x-docs/tool/" data-v-b8818f8c>工具 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/x-docs/other/" data-v-b8818f8c>其他 <!----></a></div></div><!--]--><!----><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item isExternal" href="https://github.com/SuYxh/x-docs" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav></div><!--[--><!--[--><div class="algolia-search-box" id="docsearch"></div><!--]--><!--]--></header><aside class="sidebar" data-v-83e92a68><nav class="nav-links nav" data-v-83e92a68 data-v-15acbf05><!--[--><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/x-docs/basic/" data-v-b8818f8c>基础 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/x-docs/framework/index" data-v-b8818f8c>框架 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/x-docs/project/" data-v-b8818f8c>工程化 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/x-docs/node/" data-v-b8818f8c>Node <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/x-docs/weixin/" data-v-b8818f8c>微信相关 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/x-docs/tool/" data-v-b8818f8c>工具 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/x-docs/other/" data-v-b8818f8c>其他 <!----></a></div></div><!--]--><!----><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item isExternal" href="https://github.com/SuYxh/x-docs" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav><!--[--><!--]--><ul class="sidebar-links" data-v-83e92a68><!--[--><li class="sidebar-link"><a class="sidebar-link-item active" href="/x-docs/project/超全面的前端工程化配置指南">超全面的前端工程化配置指南</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#前端工程化配置指南">前端工程化配置指南</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#示例">示例</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#初始化">初始化</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#配置">配置</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#typescript">Typescript</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#eslint-prettier">Eslint &amp; Prettier</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#husky">Husky</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#commitlint">Commitlint</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#jest">Jest</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#github-actions">Github Actions</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#结语">结语</a><!----></li></ul></li><!--]--></ul><!--[--><!--]--></aside><!-- TODO: make this button accessible --><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><p><img src="https://qn.huat.xyz/mac/20220716185129.png" alt=""></p><p><strong>程序员成长指北</strong></p><p>专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师。一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。</p><p>94篇原创内容</p><p>公众号</p><p>大厂技术  高级前端  Node进阶</p><p>点击上方 程序员成长指北，关注公众号</p><p>回复1，加入高级Node交流群</p><blockquote><p>作者：molvqingtai</p><p>原文链接: <a href="https://juejin.cn/post/6971812117993226248" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6971812117993226248</a></p></blockquote><h2 id="前端工程化配置指南">前端工程化配置指南</h2><blockquote><p>本文讲解如何构建一个工程化的前端库，并结合 Github Actions，自动发布到 Github 和 NPM 的整个详细流程。</p></blockquote><h2 id="示例">示例</h2><blockquote><p>我们经常看到像 Vue、React 这些流行的开源项目有很多配置文件，他们是干什么用的？他们的 Commit、Release 记录都那么规范，是否基于某种约定？</p></blockquote><p><strong>废话少说，先上图！</strong></p><p><img src="https://qn.huat.xyz/mac/20220716185137.png" alt="图片"> 上图标红就是相关的工程化配置，有 Linter、Tests，Github Actions 等，覆盖开发、测试、发布的整个流程。</p><p><strong>相关配置清单</strong></p><ul><li><p>Eslint</p></li><li><p>Prettier</p></li><li><p>Commitlint</p></li><li><p>Husky</p></li><li><p>Jest</p></li><li><p>GitHub Actions</p></li><li><p>Semantic Release</p></li></ul><p>下面我们从创建一个 TypeScript 项目开始，一步一步完成所有的工程化配置，并说明每个配置含义以及容易踩的坑。</p><h2 id="初始化">初始化</h2><p>为了避免兼容性问题，建议先将 node 升级到最新的长期支持版本。</p><p>首先在 Github 上创建一个 repo,拉下来之后通过<code>npm init -y</code>初始化。然后创建<code>src</code>文件夹，写入<code>index.ts</code>。</p><p><code>package.json</code> 生成之后，我需要添加如下配置项:</p><div class="language-auto"><pre><code>   &quot;main&quot;: &quot;index.js&quot;,
+  &quot;type&quot;: &quot;module&quot;,
   &quot;scripts&quot;: {
     &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
   },
+  &quot;publishConfig&quot;: {
+    &quot;access&quot;: &quot;public&quot;
+  }
</code></pre></div><p>我们将项目定义为ESM规范,前端社区正逐渐向ESM标准迁移，从Node v12.0.0开始，只要设置了 <code>&quot;type&quot;: &quot;module&quot;</code>, Node 会将整个项目视为ESM规范，我们就可以直接写裸写<code>import/export</code>。</p><p><code>publishConfig.access</code>表示当前项目发布到NPM的访问级别，它有 <code>restricted</code>和<code>public</code>两个选项,<code>restricted</code>表示我们发布到NPM上的是私有包（收费），访问级别默认为<code>restricted</code>,因为我们是开源项目所以标记为<code>public</code>。</p><h2 id="配置">配置</h2><p>创建项目之后，我们开始安装工程化相关的依赖，因为我们是 TypeScript 项目，所以也需要安装 TypeScript 的依赖。</p><h3 id="typescript">Typescript</h3><p>先安装 TypeScript，然后使用 <code>tsc</code> 命名生成 <code>tsconfig.json</code>。</p><div class="language-auto"><pre><code>npm i typescript -D
npx tsc --init
</code></pre></div><p>然后我们需要添加修改 <code>tsconfig.json</code> 的配置项，如下：</p><div class="language-auto"><pre><code>{
  &quot;compilerOptions&quot;: {
    /* Basic Options */
    &quot;baseUrl&quot;: &quot;.&quot;, // 模块解析根路径，默认为 tsconfig.json 位于的目录
    &quot;rootDir&quot;: &quot;src&quot;, // 编译解析根路径，默认为 tsconfig.json 位于的目录
    &quot;target&quot;: &quot;ESNEXT&quot;, // 指定输出 ECMAScript 版本，默认为 es5
    &quot;module&quot;: &quot;ESNext&quot;, // 指定输出模块规范，默认为 Commonjs
    &quot;lib&quot;: [&quot;ESNext&quot;, &quot;DOM&quot;], // 编译需要包含的 API，默认为 target 的默认值
    &quot;outDir&quot;: &quot;dist&quot;, // 编译输出文件夹路径，默认为源文件同级目录
    &quot;sourceMap&quot;: true, // 启用 sourceMap，默认为 false
    &quot;declaration&quot;: true, // 生成 .d.ts 类型文件，默认为 false
    &quot;declarationDir&quot;: &quot;dist/types&quot;, // .d.ts 类型文件的输出目录，默认为 outDir 目录
    /* Strict Type-Checking Options */
    &quot;strict&quot;: true, // 启用所有严格的类型检查选项，默认为 true
    &quot;esModuleInterop&quot;: true, // 通过为导入内容创建命名空间，实现 CommonJS 和 ES 模块之间的互操作性，默认为 true
    &quot;skipLibCheck&quot;: true, // 跳过导入第三方 lib 声明文件的类型检查，默认为 true
    &quot;forceConsistentCasingInFileNames&quot;: true, // 强制在文件名中使用一致的大小写，默认为 true
    &quot;moduleResolution&quot;: &quot;Node&quot;, // 指定使用哪种模块解析策略，默认为 Classic
  },
  &quot;include&quot;: [&quot;src&quot;] // 指定需要编译文件，默认当前目录下除了 exclude 之外的所有.ts, .d.ts,.tsx 文件
} 
</code></pre></div><p>更多详细配置参考：<a href="http://www.typescriptlang.org/tsconfig" target="_blank" rel="noopener noreferrer">www.typescriptlang.org/tsconfig</a></p><p>注意的点，如果你的项目涉及到<code>WebWorker API</code>，需要添加到 <code>lib</code> 字段中</p><div class="language-auto"><pre><code>&quot;lib&quot;: [&quot;ESNext&quot;, &quot;DOM&quot;, &quot;WebWorker&quot;],
</code></pre></div><p>然后我们将编译后的文件路径添加到 <code>package.json</code>，并在 <code>scripts</code> 中添加编译命令。</p><div class="language-auto"><pre><code>-  &quot;main&quot;: &quot;index.js&quot;,
+  &quot;main&quot;: &quot;dist/index.js&quot;,
+  &quot;types&quot;: &quot;dist/types/index.d.ts&quot;
   &quot;type&quot;: &quot;module&quot;,
-   &quot;scripts&quot;: {
-     &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
-   },
+   &quot;scripts&quot;: {
+     &quot;dev&quot;: &quot;tsc --watch&quot;,
+     &quot;build&quot;: &quot;npm run clean &amp;&amp; tsc&quot;,
+     &quot;clean&quot;: &quot;rm -rf dist&quot;
+  },
   &quot;publishConfig&quot;: {
     &quot;access&quot;: &quot;public&quot;
   }
</code></pre></div><p><code>types</code> 配置项是指定编译生成的类型文件，如果 <code>compilerOptions.declarationDir</code> 指定的是<code>dist</code>，也就是源码和 <code>.d.ts</code> 同级，那么<code>types</code>可以省略。</p><p>验证配置是否生效，在 <code>index.ts</code> 写入</p><div class="language-auto"><pre><code>const calc = (a: number, b: number) =&gt; {
  return a - b
}
console.log(calc(1024, 28))
</code></pre></div><p>在控制台中执行</p><div class="language-auto"><pre><code>npm run build &amp;&amp; node dist/index.js
</code></pre></div><p>会在 <code>dist</code> 目录中生成 <code>types/index.d.ts</code>、<code>index.js</code>、<code>index.js.map</code>，并打印 <code>996</code>。</p><h3 id="eslint-prettier">Eslint &amp; Prettier</h3><p>代码规范离不开各种 <code>Linter</code>, 之所以把这两个放在一起讲，借用 <code>Prettier</code> 官网的一句话：“使用 Prettier 解决代码格式问题，使用 linters 解决代码质量问题”。虽然<code>eslint</code>也有格式化功能，但是<code>prettier</code>的格式化功能更强大。</p><p>大部分同学编辑器都装了prettier-vscode和eslint-vscode这两个插件，如果你项目只有其中一个的配置，因为这两者部分格式化的功能有差异，那么就会造成一个的问题，代码分别被两个插件分别格式化一次，网上解决<code>prettier</code>+<code>eslint</code>冲突的方案五花八门，甚至还有把整个<code>rules</code>列表贴出来的。</p><p>那这里我们按照官方推荐，用最少的配置去解决<code>prettier</code>和<code>eslint</code>的集成问题。</p><h4 id="eslint">Eslint</h4><p>首先安装 <code>eslint</code>，然后利用 <code>eslint</code> 的命令行工具生成基本配置。</p><div class="language-auto"><pre><code>npm i eslint -D
npx eslint --init
</code></pre></div><p>执行上面命令后会提示一些选项，我们依次选择符合我们项目的配置。</p><p>注意，这里 <code>eslint</code> 推荐了三种社区主流的规范，Airbnb、Standard、Google，因个人爱好我选择了不写分号的 Standard规范。</p><p>生成的<code>.eslintrc.cjs</code>文件应该长这样</p><div class="language-auto"><pre><code>module.exports = {
  env: {
    browser: true,
    es2021: true,
    node: true
  },
  extends: [
    &#39;standard&#39;
  ],
  parser: &#39;@typescript-eslint/parser&#39;,
  parserOptions: {
    ecmaVersion: 12,
    sourceType: &#39;module&#39;
  },
  plugins: [
    &#39;@typescript-eslint&#39;
  ],
  rules: {
  }
}
</code></pre></div><p>有些同学可能就要问了，这里为什么生成的配置文件名称是<code>.eslintrc.cjs</code>而不是<code>.eslintrc.js</code>？</p><p>因为我们将项目定义为<code>ESM</code>，<code>eslit --init</code>会自动识别<code>type</code>，并生成兼容的配置文件名称，如果我们改回<code>.js</code>结尾，再运行<code>eslint</code>将会报错。出现这个问题是<code>eslint</code>内部使用了<code>require()</code>语法读取配置。</p><p>同样，这个问题也适用于其他功能的配置，比如后面会讲到的<code>Prettier</code>、<code>Commitlint</code>等，配置文件都不能以<code>xx.js</code>结尾，而要改为当前库支持的其他配置文件格式，如：<code>.xxrc</code>、<code>.xxrc.json</code>、<code>.xxrc.yml</code>。</p><p>验证配置是否生效，修改<code>index.ts</code></p><div class="language-auto"><pre><code>  const calc = (a: number, b: number) =&gt; {
    return a - b
  }
- console.log(calc(1024, 28))
+ // console.log(calc(1024, 28))
</code></pre></div><p>在<code>package.json</code>中添加<code>lint</code>命令</p><div class="language-auto"><pre><code>  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;tsc --watch&quot;,
    &quot;build&quot;: &quot;npm run clean &amp;&amp; tsc&quot;,
+   &quot;lint&quot;: &quot;eslint src --ext .js,.ts --cache --fix&quot;,
    &quot;clean&quot;: &quot;rm -rf dist&quot;
  },
</code></pre></div><p>然后在控制台执行 <code>lint</code>,<code>eslint</code>将会提示 1 条错误信息，说明校验生效。</p><div class="language-auto"><pre><code>npm run lint
# 1:7  error  &#39;calc&#39; is assigned a value but never used  no-unused-vars
</code></pre></div><p>因为是 Typescript 项目所以我们还要添加Standard规范提供的 TypeScrip 扩展配置(其他规范同理)</p><p>安装eslint-config-standard-with-typescript</p><div class="language-auto"><pre><code>npm i eslint-config-standard-with-typescript -D
</code></pre></div><p>添加修改 <code>.eslintrc.cjs</code></p><div class="language-auto"><pre><code>    module.exports = {
      env: {
        browser: true,
        es2021: true,
        node: true
      },
-     extends: [&#39;standard&#39;]
+     extends: [&#39;standard&#39;, &#39;eslint-config-standard-with-typescript&#39;],
      parser: &#39;@typescript-eslint/parser&#39;,
      parserOptions: {
        ecmaVersion: 12,
        sourceType: &#39;module&#39;,
+       project: &#39;./tsconfig.json&#39;
      },
      plugins: [&#39;@typescript-eslint&#39;],
      rules: {}
    }

</code></pre></div><p>验证配置是否生效</p><p>在控制台执行<code>lint</code>,<code>eslint</code>将会提示 2 条错误信息，说明校验生效。</p><div class="language-auto"><pre><code>npm run lint
# 1:7  error  &#39;calc&#39; is assigned a value but never used  no-unused-vars
# 1:14 error  Missing return type on function 
</code></pre></div><h4 id="prettier">Prettier</h4><p>现在我们按照官网的推荐方式，把 <code>prettier</code> 集成到 <code>eslint</code> 的校验中。</p><p>安装 <code>prettier</code> 并初始化配置文件</p><div class="language-auto"><pre><code>npm i prettier -D
echo {}&gt; .prettierrc.json
</code></pre></div><p>然后在<code>.prettierrc.json</code>添加配置，这里只需要添加和你所选规范冲突的部分。</p><div class="language-auto"><pre><code>{
  &quot;semi&quot;: false, // 是否使用分号
  &quot;singleQuote&quot;: true, // 使用单引号代替双引号
  &quot;trailingComma&quot;: &quot;none&quot; // 多行时尽可能使用逗号结尾
}
</code></pre></div><p>更多配置详见：<a href="http://prettier.io/docs/en/opt%E2%80%A6" target="_blank" rel="noopener noreferrer">prettier.io/docs/en/opt…</a></p><p>安装解决冲突需要用到的两个依赖</p><ul><li><p>eslint-config-prettier 关闭可能与 <code>prettier</code> 冲突的规则</p></li><li><p>eslint-plugin-prettier 使用 <code>prettier</code> 代替 <code>eslint</code> 格式化</p></li></ul><div class="language-auto"><pre><code>npm i eslint-config-prettier eslint-plugin-prettier -D
</code></pre></div><p>再添加修改 <code>.eslintrc.cjs</code>，如下：</p><div class="language-auto"><pre><code>  module.exports = {
  env: {
    browser: true,
    es2021: true,
    node: true,
  },
- extends: [&#39;standard&#39;, &#39;eslint-config-standard-with-typescript&#39;],
+ extends: [&#39;standard&#39;, &#39;eslint-config-standard-with-typescript&#39;, &#39;prettier&#39;],
  parser: &#39;@typescript-eslint/parser&#39;,
  parserOptions: {
    ecmaVersion: 12,
    sourceType: &#39;module&#39;,
    project: &#39;./tsconfig.json&#39;,
  },
- plugins: [&#39;@typescript-eslint&#39;],
+ plugins: [&#39;@typescript-eslint&#39;, &#39;prettier&#39;],
- rules: {},
+ rules: {
+   &#39;prettier/prettier&#39;: &#39;error&#39;
+ },
}
</code></pre></div><p>然后验证配置是否生效，修改<code>index.ts</code></p><div class="language-auto"><pre><code>-  const calc = (a: number, b: number) =&gt; {
+  const calc = (a: number, b: number): number =&gt; {
    return a - b
  }
- // console.log(calc(1024, 28))
+ console.log(calc(1024, 28))
</code></pre></div><p>然后在控制台执行<code>lint</code>,这里<code>prettier</code>和<code>eslint</code>的行为已保持一致，如果没有报错，那就成功了。</p><div class="language-auto"><pre><code>npm run lint
</code></pre></div><p>我们现在已经完成了<code>eslint</code>和<code>prettier</code>的集成配置。和编辑器无关，也就是说无论你使用什么编辑器，有没有安装相关插件，都不会影响代码校验的效果。</p><h3 id="husky">Husky</h3><p>因为一个项目通常是团队合作，我们不能保证每个人在提交代码之前执行一遍<code>lint</code>校验，所以需要<code>git hooks</code> 来自动化校验的过程，否则禁止提交。</p><p>安装<code>Husky</code>并生成<code>.husky</code>文件夹</p><div class="language-auto"><pre><code>npm i husky -D
npx husky install
</code></pre></div><p>然后我们需要在每次执行<code>npm install</code>时自动启用<code>husky</code></p><p>如果你的<code>npm</code>版本大于等于<code>7.1.0</code></p><div class="language-auto"><pre><code>npm set-script prepare &quot;husky install&quot;
</code></pre></div><p>否则手动在<code>package.json</code>中添加</p><div class="language-auto"><pre><code> &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;tsc --watch&quot;,
    &quot;build&quot;: &quot;npm run clean &amp;&amp; tsc&quot;,
    &quot;lint&quot;: &quot;eslint src --ext .js,.ts --cache --fix&quot;,
    &quot;clean&quot;: &quot;rm -rf dist&quot;,
+   &quot;prepare&quot;: &quot;husky install&quot;
  },
</code></pre></div><p>然后添加一个<code>lint</code>钩子</p><div class="language-auto"><pre><code>npx husky add .husky/pre-commit &quot;npm run lint&quot;
</code></pre></div><p>相当于手动在<code>.husky/pre-commit</code>文件写入以下内容：</p><div class="language-auto"><pre><code>#!/bin/sh
. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;
npm run lint
</code></pre></div><p>测试钩子是否生效，修改<code>index.ts</code></p><div class="language-auto"><pre><code>  const calc = (a: number, b: number): number =&gt; {
    return a - b
  }
- console.log(calc(1024, 28))
+ // console.log(calc(1024, 28))
</code></pre></div><p>然后提交一条<code>commit</code>,如果配置正确将会自动执行<code>lint</code>并提示 1 条错误信息，<code>commit</code>提交将会失败。</p><div class="language-auto"><pre><code>git add .
git commit -m &#39;test husky&#39;
# 1:7  error  &#39;calc&#39; is assigned a value but never used
</code></pre></div><h3 id="commitlint">Commitlint</h3><p>为什么需要 <code>Commitlint</code>，除了在后续的生成<code>changelog</code>文件和语义发版中需要提取<code>commit</code>中的信息，也利于其他同学分析你提交的代码，所以我们要约定<code>commit</code>的规范。</p><p>安装 <code>Commitlint</code></p><ul><li><p>@commitlint/cli Commitlint 命令行工具</p></li><li><p>@commitlint/config-conventional 基于 Angular 的约定规范</p></li></ul><div class="language-auto"><pre><code>npm i @commitlint/config-conventional @commitlint/cli -D
</code></pre></div><p>最后将<code>Commitlint</code>添加到钩子</p><div class="language-auto"><pre><code>npx husky add .husky/commit-msg &#39;npx --no-install commitlint --edit &quot;$1&quot;&#39;
</code></pre></div><p>创建<code>.commitlintrc</code>，并写入配置</p><div class="language-auto"><pre><code>{
  &quot;extends&quot;: [
    &quot;@commitlint/config-conventional&quot;
  ]
}
</code></pre></div><p>注意，这里配置文件名使用的是<code>.commitlintrc</code>而不是默认的<code>.commitlintrc.js</code>，详见 Eslint 章节</p><p>测试钩子是否生效，修改<code>index.ts</code>，让代码正确</p><div class="language-auto"><pre><code>  const calc = (a: number, b: number): void =&gt; {
    console.log(a - b)
  }
- // calc(1024, 28)
+ calc(1024, 28)
</code></pre></div><p>提交一条不符合规范的<code>commit</code>，提交将会失败</p><div class="language-auto"><pre><code>git add .
git commit -m &#39;add eslint and commitlint&#39;
</code></pre></div><p>修改为正确的<code>commit</code>，提交成功！</p><div class="language-auto"><pre><code>git commit -m &#39;ci: add eslint and commitlint&#39;
</code></pre></div><p><em>Angular 规范说明：</em></p><ul><li><p><em>feat</em>：新功能</p></li><li><p><em>fix</em>：修补 BUG</p></li><li><p><em>docs</em>：修改文档，比如 README, CHANGELOG, CONTRIBUTE 等等</p></li><li><p><em>style</em>：不改变代码逻辑 (仅仅修改了空格、格式缩进、逗号等等)</p></li><li><p><em>refactor</em>：重构（既不修复错误也不添加功能）</p></li><li><p><em>perf</em>：优化相关，比如提升性能、体验</p></li><li><p><em>test</em>：增加测试，包括单元测试、集成测试等</p></li><li><p><em>build</em>：构建系统或外部依赖项的更改</p></li><li><p><em>ci</em>：自动化流程配置或脚本修改</p></li><li><p><em>chore</em>：非 src 和 test 的修改，发布版本等</p></li><li><p><em>revert</em>：恢复先前的提交</p></li></ul><h3 id="jest">Jest</h3><p><em>美好生活从测试覆盖率 100% 开始。</em></p><p>安装<code>jest</code>，和类型声明<code>@types/jest</code>，它执行需要<code>ts-node</code>和<code>ts-jest</code></p><p>这里暂时固定了<code>ts-node</code>的版本为 <code>v9.1.1</code>，新版的<code>ts-node@v10.0.0</code>会导致<code>jest</code>报错，等待官方修复，详见：issues</p><div class="language-auto"><pre><code>npm i jest @types/jest ts-node@9.1.1 ts-jest -D
</code></pre></div><p>初始化配置文件</p><div class="language-auto"><pre><code>npx jest --init
</code></pre></div><p>然后修改<code>jest.config.ts</code>文件</p><div class="language-auto"><pre><code>   // A preset that is used as a base for Jest&#39;s configuration
-  // preset: undefined,
+  preset: &#39;ts-jest&#39;
</code></pre></div><p>将测试命令添加到<code>package.json</code>中。</p><div class="language-auto"><pre><code>  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;tsc --watch&quot;,
    &quot;build&quot;: &quot;npm run clean &amp;&amp; tsc&quot;,
    &quot;lint&quot;: &quot;eslint src --ext .js,.ts --cache --fix&quot;,
    &quot;clean&quot;: &quot;rm -rf dist&quot;,
    &quot;prepare&quot;: &quot;husky install&quot;,
+   &quot;test&quot;: &quot;jest&quot;
  },
</code></pre></div><p>创建测试文件夹<code>__tests__</code>和测试文件<code>__tests__/calc.spec.ts</code></p><p>修改<code>index.ts</code></p><div class="language-auto"><pre><code>  const calc = (a: number, b: number): number =&gt; {
    return a - b
  }
- // console.log(calc(1024, 28))
+ export default calc
</code></pre></div><p>然后在<code>calc.spec.ts</code>中写入测试代码</p><div class="language-auto"><pre><code>import calc from &#39;../src&#39;

test(&#39;The calculation result should be 996.&#39;, () =&gt; {
  expect(calc(1024, 28)).toBe(996)
})
</code></pre></div><p>验证配置是否生效</p><p>在控制台执行<code>test</code>，将会看到测试覆盖率 100% 的结果。</p><div class="language-auto"><pre><code>npm run test
</code></pre></div><p>最后我们给<code>__tests__</code>目录也加上<code>lint</code>校验</p><p>修改<code>package.json</code></p><div class="language-auto"><pre><code>  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;tsc --watch&quot;,
    &quot;build&quot;: &quot;npm run clean &amp;&amp; tsc&quot;,
-   &quot;lint&quot;: &quot;eslint src --ext .js,.ts --cache --fix&quot;,
+   &quot;lint&quot;: &quot;eslint src __tests__ --ext .js,.ts --cache --fix&quot;,
    &quot;clean&quot;: &quot;rm -rf dist&quot;,
    &quot;prepare&quot;: &quot;husky install&quot;,
    &quot;test&quot;: &quot;jest&quot;
  },
</code></pre></div><p>这里如果我们直接执行<code>npm run lint</code>将会报错，提示<code>__tests__</code>文件夹没有包含在<code>tsconfig.json</code>的<code>include</code>中，当我们添加到<code>include</code>之后，输出的<code>dist</code>中就会包含测试相关的文件，这并不是我们想要的效果。</p><p>我们使用<code>typescript-eslint</code>官方给出的解决方案，如下操作：</p><p>新建一个<code>tsconfig.eslint.json</code>文件，写入以下内容：</p><div class="language-auto"><pre><code>{
  &quot;extends&quot;: &quot;./tsconfig.json&quot;,
  &quot;include&quot;: [&quot;**/*.ts&quot;, &quot;**/*.js&quot;]
}
</code></pre></div><p>在<code>.eslintrc.cjs</code>中修改</p><div class="language-auto"><pre><code>  parserOptions: {
    ecmaVersion: 12,
    sourceType: &#39;module&#39;,
-   project: &#39;./tsconfig.json&#39;
+   project: &#39;./tsconfig.eslint.json&#39;
  },
</code></pre></div><p>然后验证配置是否生效，直接提交我们添加的测试文件,能正确提交说明配置成功。</p><div class="language-auto"><pre><code>git add .
git commit -m &#39;test: add unit test&#39;
</code></pre></div><h3 id="github-actions">Github Actions</h3><p>我们通过<code>Github Actions</code>实现代码合并或推送到主分支，<code>dependabot</code>机器人升级依赖等动作，会自动触发测试和发布版本等一系列流程。</p><p>在项目根目录创建<code>.github/workflows</code>文件夹，然后在里面新建<code>ci.yml</code>文件和<code>cd.yml</code>文件</p><p>在<code>ci.yml</code>文件中写入：</p><div class="language-auto"><pre><code>name: CI

on:
  push:
    branches:
      - &#39;**&#39;
  pull_request:
    branches:
      - &#39;**&#39;
jobs:
  linter:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: 16
      - run: npm ci
      - run: npm run lint
  tests:
    needs: linter
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: 16
      - run: npm ci
      - run: npm run test

</code></pre></div><p>上面配置大概意思就是，监听所有分支的<code>push</code>和<code>pull_request</code>动作，自动执行<code>linter</code>和<code>tests</code>任务。</p><p>GithubActions 更多用法参考：<a href="http://github.com/features/ac%E2%80%A6" target="_blank" rel="noopener noreferrer">github.com/features/ac…</a></p><p>然后推送代码，验证配置是否生效</p><div class="language-auto"><pre><code>git add .
git commit -m &#39;ci: use github actions&#39;
git push
</code></pre></div><p>此时打开当前项目的 <em>Github</em> 页面，然后点击顶部 <em>Actions</em> 菜单就会看到正在进行的两个任务，一个将会成功（测试），一个将会失败（发布）。</p><p>上面只是实现了代码自动测试流程，下面实现自动发布的流程。</p><p>在此之前需要到NPM网站上注册一个账号（已有可忽略），并创建一个<code>package</code>。</p><p>然后创建<code>GH_TOKEN</code>和<code>NPM_TOKEN</code>（注意，不要在代码中包含任何的 TOKEN 信息）：</p><ul><li><p>如何创建 GITHUB\_TOKEN（创建时勾选 <em>repo</em> 和 <em>workflow</em> 权限）</p></li><li><p>如何创建 NPM\_TOKEN（创建时选中 <em>Automation</em> 权限）</p></li></ul><p>将创建好的两个<code>TOKEN</code>添加到项目的 <em>Actions secrets</em> 中：</p><p><em>Github 项目首页</em> -&gt; <em>顶部 Settings 菜单</em> -&gt; <em>侧边栏 Secrets</em></p><p>然后修改<code>package.json</code>中的<code>“name”</code>，<code>“name”</code>就是你在NPM上创建的<code>package</code>的名称。</p><p>在<code>cd.yml</code>文件中写入：</p><div class="language-auto"><pre><code>name: CD

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: 16
      # https://github.com/semantic-release/git/issues/209
      - run: npm ci --ignore-scripts
      - run: npm run build
      - run: npx semantic-release
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
</code></pre></div><p>由于“黑命贵”，Github 已将新项目的默认分支名称更改为 <code>“main”</code>，详见：issues， 为了方便，后面统一称为 <em>主分支</em></p><p>所以如果你的主分支名称是<code>“main”</code>，上面的<code>branches</code>需要修改为：</p><div class="language-auto"><pre><code>on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
</code></pre></div><p>然后安装语义发版依赖，需要用到<code>semantic-release</code>和它的插件：</p><ul><li><p>semantic-release：语义发版核心库</p></li><li><p>@semantic-release/changelog：用于自动生成 <a href="http://changelog.md" target="_blank" rel="noopener noreferrer">changelog.md</a></p></li><li><p>@semantic-release/git：用于将发布时产生的更改提交回远程仓库</p></li></ul><div class="language-auto"><pre><code>npm i semantic-release @semantic-release/changelog @semantic-release/git -D
</code></pre></div><p>在项目根目录新建配置文件<code>.releaserc</code>并写入：</p><div class="language-auto"><pre><code>{
  &quot;branches&quot;: [&quot;master&quot;],
  &quot;plugins&quot;: [
    &quot;@semantic-release/commit-analyzer&quot;,
    &quot;@semantic-release/release-notes-generator&quot;,
    &quot;@semantic-release/changelog&quot;,
    &quot;@semantic-release/github&quot;,
    &quot;@semantic-release/npm&quot;,
    &quot;@semantic-release/git&quot;
  ]
}
</code></pre></div><p>这里同样，如果你的主分支名称是<code>“main”</code>，上面的<code>branches</code>需要修改为：</p><div class="language-auto"><pre><code>  &quot;branches&quot;: [&quot;+([0-9])?(.{+([0-9]),x}).x&quot;, &quot;main&quot;],
</code></pre></div><p>最后新建分支 <em>develop</em> 分支并提交工作内容。</p><div class="language-auto"><pre><code>git checkout -b develop
git add .
git commit -m &#39;feat: complete the CI/CD workflow&#39;
git push --set-upstream origin develop
git push
</code></pre></div><p>然后将 <em>develop</em> 分支合并到 <em>主分支</em>，并提交，注意：这个提交会触发测试并 <em>发布版本</em> (自动创建<code>tag</code>和<code>changelog</code>)</p><div class="language-auto"><pre><code>git checkout master
git merge develop
git push
</code></pre></div><p>完成上面操作之后，打开 <em>Github 项目主页</em> 和 <em>NPM 项目主页</em> 可以看到一个 <em>Release</em> 的更新记录。</p><p>最后切回到 <em>develop</em> 分支，创建一个自动更新依赖的<code>workflow</code>。</p><p>在<code>.github</code>文件夹中创建<code>dependabot.yml</code>文件，并写入内容：</p><div class="language-auto"><pre><code>version: 2
updates:
  # Enable version updates for npm
  - package-ecosystem: &#39;npm&#39;
    # Look for `package.json` and `lock` files in the `root` directory
    directory: &#39;/&#39;
    # Check the npm registry for updates every day (weekdays)
    schedule:
      interval: &#39;weekly&#39;
</code></pre></div><p>提交并查看 <em>workflows</em> 是否全部通过，再合并到 <em>主分支</em> 并提交，这个提交不会触发版本发布。</p><div class="language-auto"><pre><code>git pull origin master
git add .
git commit -m &#39;ci: add dependabot&#39;
git push 

git checkout master
git merge develop
git push
</code></pre></div><p>触发版本发布需要两个条件：</p><ol><li><p>只有当<code>push</code>和<code>pull_request</code>到 <em>主分支</em> 上才会触发版本发布</p></li><li><p>只有<code>commit</code>前缀为<code>feat</code>、<code>fix</code>、<code>perf</code>才会发布，否则跳过。</p></li></ol><p>更多发布规则，详见：<a href="http://github.com/semantic-re%E2%80%A6" target="_blank" rel="noopener noreferrer">github.com/semantic-re…</a></p><p>SemanticRelease 使用方式，详见：<a href="http://semantic-release.gitbook.io" target="_blank" rel="noopener noreferrer">semantic-release.gitbook.io</a></p><p><strong>如果你能正确配置上面所有步骤，并成功发布，那么恭喜你！你拥有了一个完全自动化的项目，它拥有：自动依赖更新、测试、发布，和自动生成版本信息等功能。</strong></p><p>完整的项目示例：@resreq/event-hub</p><h2 id="结语">结语</h2><p>本文未涉及到：组件库、Monorepo、Jenkins CI 等配置，但能覆盖绝大部前端项目 CI/CD 流程。</p><p>有些地方讲得比较细，甚至有些啰嗦，但还是希望能帮助到大家！撒花！🎉🎉🎉</p><p><img src="https://qn.huat.xyz/mac/20220716185154.png" alt=""></p><p><strong>程序员成长指北</strong></p><p>专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师。一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。</p><p>94篇原创内容</p><p>公众号</p><p>Node 社群</p><p>我组建了一个氛围特别好的 Node.js 社群，里面有很多 Node.js小伙伴，如果你对Node.js学习感兴趣的话（后续有计划也可以），我们可以一起进行Node.js相关的交流、学习、共建。下方加 考拉 好友回复「Node」即可。</p></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-fb8d84c6><div class="edit" data-v-fb8d84c6><div class="edit-link" data-v-fb8d84c6 data-v-1ed99556><a class="link" href="https://github.com/SuYxh/x-docs/edit/master/docs/project/超全面的前端工程化配置指南.md" target="_blank" rel="noopener noreferrer" data-v-1ed99556>在 GitHub 上编辑此页 <svg class="icon outbound icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-1ed99556><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="updated" data-v-fb8d84c6><p class="last-updated" data-v-fb8d84c6 data-v-5797b537><span class="prefix" data-v-5797b537>上次更新:</span><span class="datetime" data-v-5797b537></span></p></div></footer><!----><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"4da83083\",\"basic_index.md\":\"1d2d74e6\",\"components_button.md\":\"86c74c84\",\"components_modal.md\":\"e46b8f55\",\"components_tabs.md\":\"14ef9e3d\",\"components_tag.md\":\"ec38aee2\",\"components_vue-script.md\":\"c11a8ff9\",\"components_vue.md\":\"579787b9\",\"framework_index.md\":\"f41190ff\",\"framework_tabs.md\":\"5b8384b8\",\"node_index.md\":\"2ab4c899\",\"node_pm2自动部署node项目.md\":\"0d166f0c\",\"node_zx使用教程.md\":\"a32b524d\",\"other_index.md\":\"f2a2b862\",\"other_电商管理后台api接口文档.md\":\"0a9f4e5a\",\"project_index.md\":\"2169963d\",\"project_超全面的前端工程化配置指南.md\":\"e3106243\",\"tool_index.md\":\"2e8e3fd8\",\"weixin_index.md\":\"55f42e34\",\"basic_css_css选择器nth-child.md\":\"16874e1d\",\"basic_css_如何解决flex文本溢出问题.md\":\"2fb6ac58\",\"basic_css_超出隐藏.md\":\"06b84e3a\",\"basic_js_判断苹果手机类型.md\":\"5f2aacbc\",\"basic_js_手写promise.md\":\"c24863c0\",\"framework_vue-component_进度条组件.md\":\"69ec998a\",\"node_egg_egg实现文件上传.md\":\"520dcb91\",\"node_sequelize_sequelize简单使用.md\":\"82803c40\",\"weixin_mini-program_小程序渲染markdown.md\":\"7da438f4\",\"weixin_mini-program_小程序解析富文本.md\":\"65659dae\"}")</script>
    <script type="module" async src="/x-docs/assets/app.6a9dab50.js"></script>
  </body>
</html>